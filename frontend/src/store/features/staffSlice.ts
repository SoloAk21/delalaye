import { createAsyncThunk, createSlice } from "@reduxjs/toolkit"
import axios,{isAxiosError} from "axios"
// import axios from '../../utils/axios'
import { Staff } from '../../model/models'
import { toast } from 'sonner'
import { apiUrl } from "../../utils/api.util"

export interface StaffState {
  staffs: Staff[]
  staff:Staff|null
  status: "idle" | "loading" | "failed"
  task:string
  error: string | null;

}

const initialState: StaffState = {
  staffs: [],
  staff:null,
  status: "idle",
  task:'',
  error:null

}
// interface UpdateStaffProps {
//   staffId: string;
//   updatedStaff: Staff;
// }

export const getRegisteredStaffs = createAsyncThunk("staff/getRegisteredStaffs", async () => {
  const response = await axios.get(`${apiUrl}/api/cs/staffs`)
  
  return response.data
});

export const getStaffs = createAsyncThunk("staff/getStaffs", async () => {
  const response = await axios.get(`${apiUrl}/api/admin/staffs`)
  
  return response.data
});


export const getStaff = createAsyncThunk("staff/getStaff", async (id:string) => {
  const response = await axios.get(`${apiUrl}/api/staffs/${id}`);
  
  return response.data;
});

interface AddStafProp {
  staff:Staff
  setOpenUpdatePopup:React.Dispatch<React.SetStateAction<boolean>>
}
export const addStaff = createAsyncThunk(
  'staff/addStaff',
  async (prop: AddStafProp,thunkAPI) => {
    try {
      const {staff,setOpenUpdatePopup}= prop;
    const response = await axios.post(`${apiUrl}/api/admin/staff`, staff);
    setOpenUpdatePopup(false);
    return response.data;
    } catch (error) {
      let errors: any = []
      if (isAxiosError(error)) {
        errors = error.response?.data.errors
        if (errors) {
          errors.forEach((err: any) => {
            toast.error(err?.msg);
          })
        }
      } else {
        errors = error && error.toString()
      }
      console.error(errors)
      return thunkAPI.rejectWithValue(errors)
    }
    
  }
);


interface UpdateStaffProp   {
  setOpenUpdatePopup: React.Dispatch<React.SetStateAction<boolean>>
  id:number
updatedStaff: Staff;

}
export const updateStaff = createAsyncThunk(
  'staff/updateStaff',
  async (updateProps: UpdateStaffProp, 
    thunkAPI
    ) => {
    try {
      const { id, updatedStaff ,setOpenUpdatePopup} = updateProps;
      
      const response = await axios.put(`${apiUrl}/api/admin/staff/${id}`, updatedStaff);
      setOpenUpdatePopup(false)
      toast.success(`Staff updated successfully.`)
      return response.data;
    } catch (error) {
      let errors: any = []
      if (isAxiosError(error)) {
        errors = error.response?.data.errors
        if (errors) {
          errors.forEach((err: any) => {
            toast.error(err?.msg)
            // store.dispatch(setAlert({ alertType: 'error', msg: err?.msg }))
          })
        }
      } else {
        errors = error && error.toString()
      }
      console.error(errors)
      return thunkAPI.rejectWithValue(errors)
    }
  }
);




export const deleteStaff = createAsyncThunk(
  'staff/deleteStaff',
  async (staffID: string, 
    // { rejectWithValue }
    )=> {
    try {
      await axios.delete(`${apiUrl}/api/admin/staffs/${staffID}`);
toast.success('Staff deleted');
      return staffID;
    } catch (error) {
      // return rejectWithValue(error.response.data);
    }
  }
);

export const StaffSlice = createSlice({
  name: "staff",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
  
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
    .addCase(addStaff.pending, (state) => {
      state.status = "loading";
    })
    .addCase(addStaff.fulfilled, (state, action) => {
      state.status = "idle";
      state.staffs.push(action.payload);
    })
    .addCase(addStaff.rejected, (state) => {
      state.status = "failed";
      // state.error = action.error.message;
    })
    
      .addCase(getStaffs.pending, state => {
        state.status = "loading"
      })
      .addCase(getStaffs.fulfilled, (state, action) => {
        // state.staffs = action.payload.allStaffs;
        state.staffs= action.payload.staffs;
        state.status = "idle"
      })
     
      .addCase(getStaffs.rejected, state => {
        state.status = "failed"
      })
    
      .addCase(getStaff.pending, state => {
        state.status = "loading"
      })
      .addCase(getStaff.fulfilled, (state, action) => {
        state.staff = action.payload;
        state.status = "idle"
      })
      .addCase(getStaff.rejected, state => {
        state.status = "failed"
      })
      
      .addCase(deleteStaff.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(deleteStaff.fulfilled, (state, action) => {
        state.status = 'idle';
        state.staffs = state.staffs.filter(
          (usr) => usr.id !== action.payload
        );
      })
      .addCase(deleteStaff.rejected, (state) => {
        state.status = 'failed';
      })
      
      .addCase(updateStaff.pending, (state) => {
        state.status = 'loading';
        state.error = null;
      })
      .addCase(updateStaff.fulfilled, (state, action) => {
        state.status = 'idle';
        state.error = null;

        const updatedStaff = action.payload;
        const staffIndex = state.staffs.findIndex((staff) => staff.id === updatedStaff.id);
        if (staffIndex !== -1) {
          state.staffs[staffIndex] = updatedStaff;
        }
      })
      .addCase(updateStaff.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      });

  },
})

export default StaffSlice.reducer