import { createAsyncThunk, createSlice } from "@reduxjs/toolkit"
import axios,{isAxiosError} from "axios"
// import axios from '../../utils/axios'
import { NewService, Service, } from '../../model/models'
import { toast } from 'sonner'
import { apiUrl } from "../../utils/api.util"

export interface ServiceState {
  services: Service[]
  service:Service|null
  status: "idle" | "loading" | "failed"
  task:string
  error: string | null;

}

const initialState: ServiceState = {
  services: [],
  service:null,
  status: "idle",
  task:'',
  error:null

}
// interface UpdateStaffProps {
//   staffId: string;
//   updatedStaff: User;
// }

export const getServices = createAsyncThunk("service/getServices", async () => {
  const response = await axios.get(`${apiUrl}/api/admin/services`)
  
  return response.data
});

interface AddServiceProp extends NewService {
    setOpenUpdatePopup: React.Dispatch<React.SetStateAction<boolean>>;
    setValues:React.Dispatch<React.SetStateAction<NewService>>
}

export const addService = createAsyncThunk(
  'service/addService',
  async (service: AddServiceProp,thunkAPI) => {
    try {
     const response = await axios.post(`${apiUrl}/api/admin/service`, service);
    service.setOpenUpdatePopup(false);
    toast.success('New service added');
    service.setValues({
      name: "",
      description: "",
      serviceRate: 10,
    })
    return response.data;   
    } catch (error) {
              let errors: any = []
      if (isAxiosError(error)) {
        errors = error.response?.data.errors
        if (errors) {
          errors.forEach((err: any) => {
            toast.error(err?.msg)
            // store.dispatch(setAlert({ alertType: 'error', msg: err?.msg }))
          })
        }
      } else {
        errors = error && error.toString()
      }
      console.error(errors)
      return thunkAPI.rejectWithValue(errors)
    }
    
  }
);


interface UpdateServiceProp  {
  setOpenUpdatePopup: React.Dispatch<React.SetStateAction<boolean>>
 updatedService: Service;

}
export const updateService = createAsyncThunk(
  'service/updateService',
  async (updateProps: UpdateServiceProp, 
    thunkAPI
    ) => {
    try {
      const {  updatedService,setOpenUpdatePopup } = updateProps;
      
      const response = await axios.put(`${apiUrl}/api/admin/service/${updatedService.id}`, updatedService);
      setOpenUpdatePopup(false)
      toast.success('Updated service')
      return response.data;
    } catch (error) {
          let errors: any = []
      if (isAxiosError(error)) {
        errors = error.response?.data.errors
        if (errors) {
          errors.forEach((err: any) => {
            toast.error(err?.msg)
            // store.dispatch(setAlert({ alertType: 'error', msg: err?.msg }))
          })
        }
      } else {
        errors = error && error.toString()
      }
      console.error(errors)
      return thunkAPI.rejectWithValue(errors)
    }
  }
);
export const deleteService = createAsyncThunk(
  'user/deleteService',
  async (staffID: number, 
   thunkAPI
    )=> {
    try {
      await axios.delete(`${apiUrl}/api/admin/staff/${staffID}`);

      return staffID;
    } catch (error) {
      let errors: any = []
      if (isAxiosError(error)) {
        errors = error.response?.data.errors
        if (errors) {
          errors.forEach((err: any) => {
            toast.error(err?.msg)
            // store.dispatch(setAlert({ alertType: 'error', msg: err?.msg }))
          })
        }
      } else {
        errors = error && error.toString()
      }
      console.error(errors)
      return thunkAPI.rejectWithValue(errors)
    }
  }
);


export const ServiceSlice = createSlice({
  name: "service",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
  
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
    .addCase(addService.pending, (state) => {
      state.status = "loading";
    })
    .addCase(addService.fulfilled, (state, action) => {
      state.status = "idle";
      state.services.push(action.payload);
    })
    .addCase(addService.rejected, (state) => {
      state.status = "failed";
      // state.error = action.error.message;
    })
      
      .addCase(getServices.pending, state => {
        state.status = "loading"
      })
      .addCase(getServices.fulfilled, (state, action) => {
        // state.users = action.payload.allUsers;
        state.services= action.payload.services;
        state.status = "idle"
      })
      .addCase(getServices.rejected, state => {
        state.status = "failed"
      })
      .addCase(deleteService.pending, (state) => {
          state.status = 'loading';
          state.error = null;
        })
        .addCase(deleteService.fulfilled, (state, action) => {
            state.status = 'idle';
            state.services = state.services.filter(
                (service) => service.id !== action.payload
                );
            })
            .addCase(deleteService.rejected, (state) => {
              state.status = 'failed';
            })
      .addCase(updateService.fulfilled, (state, action) => {
        state.status = 'idle';
        state.error = null;

        const updatedStaff = action.payload;
        const serviceIndex = state.services.findIndex((service) => service.id === updatedStaff.id);
        if (serviceIndex !== -1) {
          state.services[serviceIndex] = updatedStaff;
        }
      })
      .addCase(updateService.pending, state => {
        state.status = "loading"
      })
      .addCase(updateService.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.payload as string;
      });

  },
})

export default ServiceSlice.reducer